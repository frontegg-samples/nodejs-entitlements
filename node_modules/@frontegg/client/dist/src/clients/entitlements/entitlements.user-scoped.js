"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntitlementsUserScoped = void 0;
const types_1 = require("./types");
const types_2 = require("./storage/types");
const exp_time_utils_1 = require("./storage/exp-time.utils");
const entitlements_javascript_commons_1 = require("@frontegg/entitlements-javascript-commons");
const frontegg_entity_helper_1 = require("./helpers/frontegg-entity.helper");
class EntitlementsUserScoped {
    constructor(entity, cache, predefinedAttributes = {}) {
        this.entity = entity;
        this.cache = cache;
        this.predefinedAttributes = predefinedAttributes;
        this.permissions = [];
        this.permissionRegexps = [];
        this.tenantId = entity.tenantId;
        this.userId = (0, frontegg_entity_helper_1.findUserId)(entity);
        const entityWithPossiblePermissions = entity;
        if (Array.isArray(entityWithPossiblePermissions.permissions)) {
            entityWithPossiblePermissions.permissions.forEach(permission => {
                if (permission.includes('*')) {
                    this.permissionRegexps.push((0, entitlements_javascript_commons_1.createPermissionCheckRegex)(permission));
                }
                else {
                    this.permissions.push(permission);
                }
            });
        }
    }
    async isEntitledToFeature(featureKey, attributes = {}) {
        const isEntitledResult = await this.getEntitlementResult(featureKey);
        if (!isEntitledResult.result) {
            const ffResult = await this.getFeatureFlagResult(featureKey, { ...attributes, ...this.predefinedAttributes });
            if (ffResult.result) {
                return ffResult;
            }
            // else: just return result & justification of entitlements
        }
        return isEntitledResult;
    }
    async getEntitlementResult(featureKey) {
        const tenantEntitlementExpTime = await this.cache.getEntitlementExpirationTime(featureKey, this.tenantId);
        const userEntitlementExpTime = this.userId
            ? await this.cache.getEntitlementExpirationTime(featureKey, this.tenantId, this.userId)
            : undefined;
        const expTimes = [tenantEntitlementExpTime, userEntitlementExpTime].filter((v) => v !== undefined);
        const expTime = expTimes.length === 0 ? undefined : (0, exp_time_utils_1.pickExpTimestamp)(expTimes);
        if (expTime === undefined) {
            return {
                result: false,
                justification: types_1.EntitlementJustifications.MISSING_FEATURE,
            };
        }
        else if (expTime === types_2.NO_EXPIRE || expTime > new Date().getTime()) {
            return {
                result: true,
            };
        }
        else {
            return {
                result: false,
                justification: types_1.EntitlementJustifications.BUNDLE_EXPIRED,
            };
        }
    }
    async getFeatureFlagResult(featureKey, attributes) {
        const featureFlags = await this.cache.getFeatureFlags(featureKey);
        for (const flag of featureFlags) {
            const ffResult = (0, entitlements_javascript_commons_1.evaluateFeatureFlag)(flag, attributes);
            if ((ffResult === null || ffResult === void 0 ? void 0 : ffResult.treatment) === entitlements_javascript_commons_1.TreatmentEnum.True) {
                return { result: true };
            }
        }
        return {
            result: false,
            justification: types_1.EntitlementJustifications.MISSING_FEATURE,
        };
    }
    hasPermission(permissionKey) {
        return this.permissions.includes(permissionKey) ||
            this.permissionRegexps.some(regex => regex.test(permissionKey));
    }
    async isEntitledToPermission(permissionKey, attributes = {}) {
        if (!this.hasPermission(permissionKey)) {
            return {
                result: false,
                justification: types_1.EntitlementJustifications.MISSING_PERMISSION,
            };
        }
        const features = await this.cache.getLinkedFeatures(permissionKey);
        if (features.size === 0) {
            return { result: true };
        }
        let hasExpired = false;
        for (const feature of features) {
            const isEntitledToFeatureResult = await this.isEntitledToFeature(feature, attributes);
            if (isEntitledToFeatureResult.result === true) {
                return {
                    result: true,
                };
            }
            else if (isEntitledToFeatureResult.justification === types_1.EntitlementJustifications.BUNDLE_EXPIRED) {
                hasExpired = true;
            }
        }
        return {
            result: false,
            justification: hasExpired ? types_1.EntitlementJustifications.BUNDLE_EXPIRED : types_1.EntitlementJustifications.MISSING_FEATURE,
        };
    }
    async isEntitledTo({ featureKey, permissionKey, }, attributes = {}) {
        if (featureKey && permissionKey) {
            throw new Error('Cannot check both feature and permission entitlement at the same time.');
        }
        else if (featureKey !== undefined) {
            return this.isEntitledToFeature(featureKey, attributes);
        }
        else if (permissionKey !== undefined) {
            return this.isEntitledToPermission(permissionKey, attributes);
        }
        else {
            throw new Error('Neither feature, nor permission key is provided.');
        }
    }
}
exports.EntitlementsUserScoped = EntitlementsUserScoped;
//# sourceMappingURL=entitlements.user-scoped.js.map