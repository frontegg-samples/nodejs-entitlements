"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryEntitlementsCache = void 0;
const in_memory_cache_key_utils_1 = require("./in-memory.cache-key.utils");
const NodeCache = require("node-cache");
const exp_time_utils_1 = require("../exp-time.utils");
const sources_mapper_1 = require("./mappers/sources.mapper");
const helper_1 = require("./mappers/helper");
class InMemoryEntitlementsCache {
    constructor(revision) {
        this.revision = revision;
        this.nodeCache = new NodeCache({
            useClones: false,
            errorOnMissing: true,
        });
    }
    async getEntitlementExpirationTime(featKey, tenantId, userId) {
        const entitlementsMap = this.nodeCache.get(in_memory_cache_key_utils_1.ENTITLEMENTS_MAP_KEY);
        if (!entitlementsMap) {
            throw new Error('Cache is not properly initialized. Feature&Tenant&User => ExpirationTime map is missing.');
        }
        const entitlementKey = (0, in_memory_cache_key_utils_1.getFeatureEntitlementKey)(featKey, tenantId, userId);
        return entitlementsMap.get(entitlementKey);
    }
    async getLinkedFeatures(permissionKey) {
        const permissionsMap = this.nodeCache.get(in_memory_cache_key_utils_1.PERMISSIONS_MAP_KEY);
        if (!permissionsMap) {
            throw new Error('Cache is not properly initialized. Permissions => Features map is missing.');
        }
        const mapping = permissionsMap.get(permissionKey);
        return mapping || new Set();
    }
    async getFeatureFlags(featureKey) {
        var _a;
        return ((_a = this.nodeCache.get(in_memory_cache_key_utils_1.FEAT_TO_FLAG_MAP_KEY)) === null || _a === void 0 ? void 0 : _a.get(featureKey)) || [];
    }
    static initialize(data, revPrefix) {
        const cache = new InMemoryEntitlementsCache(revPrefix !== null && revPrefix !== void 0 ? revPrefix : data.snapshotOffset.toString());
        // build source structure
        const { entitlements: e10sSourceData, featureFlags: ffSourceData } = new sources_mapper_1.SourcesMapper(data.data).buildSources();
        cache.nodeCache.set(in_memory_cache_key_utils_1.SRC_BUNDLES_KEY, e10sSourceData);
        // setup data for SDK to work
        cache.setupEntitlementsReadModel(e10sSourceData);
        cache.setupPermissionsReadModel(e10sSourceData);
        cache.setupFeatureFlagsReadModel(ffSourceData);
        return cache;
    }
    setupEntitlementsReadModel(src) {
        const entitlementsReadModel = new Map();
        // iterating over bundles..
        src.forEach((singleBundle) => {
            // iterating over tenant&user entitlements
            singleBundle.user_entitlements.forEach((usersOfTenantEntitlements, tenantId) => {
                // iterating over per-user entitlements
                usersOfTenantEntitlements.forEach((expTimes, userId) => {
                    const entitlementExpTime = (0, exp_time_utils_1.pickExpTimestamp)(expTimes);
                    singleBundle.features.forEach((feature) => {
                        entitlementsReadModel.set((0, in_memory_cache_key_utils_1.getFeatureEntitlementKey)(feature.key, tenantId, userId), entitlementExpTime);
                    });
                });
            });
            // iterating over tenant entitlements
            singleBundle.tenant_entitlements.forEach((expTimes, tenantId) => {
                singleBundle.features.forEach((feature) => {
                    const entitlementExpTime = (0, exp_time_utils_1.pickExpTimestamp)(expTimes);
                    entitlementsReadModel.set((0, in_memory_cache_key_utils_1.getFeatureEntitlementKey)(feature.key, tenantId), entitlementExpTime);
                });
            });
        });
        this.nodeCache.set(in_memory_cache_key_utils_1.ENTITLEMENTS_MAP_KEY, entitlementsReadModel);
    }
    setupPermissionsReadModel(src) {
        const permissionsReadModel = new Map();
        src.forEach((singleBundle) => {
            singleBundle.features.forEach((feature) => {
                feature.permissions.forEach((permission) => {
                    (0, helper_1.ensureSetInMap)(permissionsReadModel, permission).add(feature.key);
                });
            });
        });
        this.nodeCache.set(in_memory_cache_key_utils_1.PERMISSIONS_MAP_KEY, permissionsReadModel);
    }
    setupFeatureFlagsReadModel(src) {
        this.nodeCache.set(in_memory_cache_key_utils_1.FEAT_TO_FLAG_MAP_KEY, src);
    }
    async clear() {
        this.nodeCache.del(this.nodeCache.keys());
    }
    async shutdown() {
        this.nodeCache.close();
    }
}
exports.InMemoryEntitlementsCache = InMemoryEntitlementsCache;
//# sourceMappingURL=in-memory.cache.js.map