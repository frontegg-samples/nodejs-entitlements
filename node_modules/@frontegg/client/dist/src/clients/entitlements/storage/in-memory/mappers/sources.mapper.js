"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourcesMapper = void 0;
const types_1 = require("../types");
const feature_flag_tuple_mapper_1 = require("./feature-flag-tuple.mapper");
const types_2 = require("../../types");
const helper_1 = require("./helper");
class SourcesMapper {
    constructor(dto) {
        this.dto = dto;
    }
    buildSources() {
        return {
            entitlements: this.buildEntitlementsSources(this.dto.featureBundles, this.dto.features, this.dto.entitlements),
            featureFlags: this.buildFeatureFlagsSources(this.dto.featureFlags, this.dto.features),
        };
    }
    buildEntitlementsSources(bundles, features, entitlements) {
        const bundlesMap = new Map();
        const unbundledFeaturesIds = new Set();
        // helper features maps
        const featuresMap = new Map();
        features.forEach((feat) => {
            const [id, key, permissions] = feat;
            featuresMap.set(id, {
                id,
                key,
                permissions: new Set(permissions || []),
            });
            unbundledFeaturesIds.add(id);
        });
        // initialize bundles map
        bundles.forEach((bundle) => {
            const [id, featureIds] = bundle;
            bundlesMap.set(id, {
                id,
                user_entitlements: new Map(),
                tenant_entitlements: new Map(),
                features: new Map(featureIds.reduce((prev, fId) => {
                    const featSource = featuresMap.get(fId);
                    if (!featSource) {
                        // TODO: issue warning here!
                    }
                    else {
                        prev.push([featSource.key, featSource]);
                        // mark feature as bundled
                        unbundledFeaturesIds.delete(fId);
                    }
                    return prev;
                }, [])),
            });
        });
        // fill bundles with entitlements
        entitlements.forEach((entitlement) => {
            const [featureBundleId, tenantId, userId, expirationDate] = entitlement;
            const bundle = bundlesMap.get(featureBundleId);
            if (bundle) {
                if (userId) {
                    // that's user-targeted entitlement
                    const tenantUserEntitlements = (0, helper_1.ensureMapInMap)(bundle.user_entitlements, tenantId);
                    const usersEntitlements = (0, helper_1.ensureArrayInMap)(tenantUserEntitlements, userId);
                    usersEntitlements.push(this.parseExpirationTime(expirationDate));
                }
                else {
                    // that's tenant-targeted entitlement
                    const tenantEntitlements = (0, helper_1.ensureArrayInMap)(bundle.tenant_entitlements, tenantId);
                    tenantEntitlements.push(this.parseExpirationTime(expirationDate));
                }
            }
            else {
                // TODO: issue warning here!
            }
        });
        // make "dummy" bundle for unbundled features
        bundlesMap.set(types_1.UNBUNDLED_SRC_ID, {
            id: types_1.UNBUNDLED_SRC_ID,
            user_entitlements: new Map(),
            tenant_entitlements: new Map(),
            features: new Map([...unbundledFeaturesIds.values()].map((fId) => {
                const featSource = featuresMap.get(fId);
                return [featSource.key, featSource];
            })),
        });
        return bundlesMap;
    }
    buildFeatureFlagsSources(flags, features) {
        const featureKeys = features.map((tuple) => tuple[1]);
        const source = new Map();
        flags.forEach((flagTuple) => {
            const featureKey = flagTuple[0];
            if (featureKeys.includes(featureKey)) {
                (0, helper_1.ensureArrayInMap)(source, featureKey).push((0, feature_flag_tuple_mapper_1.mapFromTuple)(flagTuple));
            }
        }, []);
        return source;
    }
    parseExpirationTime(time) {
        if (time !== undefined && time !== null) {
            return new Date(time).getTime();
        }
        return types_2.NO_EXPIRE;
    }
}
exports.SourcesMapper = SourcesMapper;
//# sourceMappingURL=sources.mapper.js.map