"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdentityClient = void 0;
const axios_1 = require("axios");
const authenticator_1 = require("../../authenticator");
const config_1 = require("../../config");
const logger_1 = require("../../components/logger");
const frontegg_context_1 = require("../../components/frontegg-context");
const types_1 = require("./types");
const token_resolvers_1 = require("./token-resolvers");
const exceptions_1 = require("./exceptions");
const tokenResolvers = [token_resolvers_1.authorizationHeaderResolver, token_resolvers_1.accessTokenHeaderResolver];
class IdentityClient {
    static getInstance() {
        if (!IdentityClient.instance) {
            IdentityClient.instance = new IdentityClient(frontegg_context_1.FronteggContext.getContext());
        }
        return IdentityClient.instance;
    }
    constructor(context) {
        this.publicKey = '';
        this.context = context;
    }
    async getPublicKey() {
        if (!this.publicKey) {
            logger_1.default.info('going to retrieve public key');
            await this.fetchPublicKey();
            logger_1.default.info('Retrieved public key');
        }
        return this.publicKey;
    }
    async validateToken(token, options, type = types_1.AuthHeaderType.JWT) {
        const { token: formattedToken, publicKey } = await this.extractTokenCredentials(token, type);
        const resolver = tokenResolvers.find((resolver) => resolver.shouldHandle(type));
        if (!resolver) {
            logger_1.default.error('Failed to find token resolver');
            throw new exceptions_1.FailedToAuthenticateException();
        }
        return await resolver.validateToken(formattedToken, publicKey, options);
    }
    async validateIdentityOnToken(token, options) {
        const { token: formattedToken, publicKey } = await this.extractTokenCredentials(token, types_1.AuthHeaderType.JWT);
        const entity = await token_resolvers_1.authorizationHeaderResolver.validateToken(formattedToken, publicKey, options);
        return entity;
    }
    async extractTokenCredentials(token, type) {
        if (type === types_1.AuthHeaderType.JWT) {
            try {
                token = token.replace('Bearer ', '');
            }
            catch (e) {
                logger_1.default.error('Failed to extract token - ', token);
                throw new exceptions_1.FailedToAuthenticateException();
            }
        }
        let publicKey;
        try {
            publicKey = await this.getPublicKey();
        }
        catch (e) {
            logger_1.default.error('failed to get public key - ', e);
            throw new exceptions_1.FailedToAuthenticateException();
        }
        return { publicKey, token };
    }
    async fetchPublicKey() {
        const authenticator = new authenticator_1.FronteggAuthenticator();
        logger_1.default.info('going to authenticate');
        const { FRONTEGG_CLIENT_ID, FRONTEGG_API_KEY } = this.context;
        await authenticator.init(FRONTEGG_CLIENT_ID || process.env.FRONTEGG_CLIENT_ID || '', FRONTEGG_API_KEY || process.env.FRONTEGG_API_KEY || '');
        logger_1.default.info('going to get identity service configuration');
        const response = await axios_1.default.get(`${config_1.config.urls.identityService}/resources/configurations/v1`, {
            headers: {
                'x-access-token': authenticator.accessToken,
            },
        });
        logger_1.default.info('got identity service configuration');
        // Get the public key
        const { publicKey } = response.data;
        // And save it as member of the class
        logger_1.default.info('going to extract public key from response');
        this.publicKey = publicKey;
        await authenticator.shutdown();
    }
}
exports.IdentityClient = IdentityClient;
//# sourceMappingURL=identity-client.js.map