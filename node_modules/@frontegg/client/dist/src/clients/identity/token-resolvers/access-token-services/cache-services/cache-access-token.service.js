"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheAccessTokenService = void 0;
const exceptions_1 = require("../../../exceptions");
class CacheAccessTokenService {
    constructor(entityCacheManager, activeAccessTokensCacheManager, accessTokenService, type) {
        this.entityCacheManager = entityCacheManager;
        this.activeAccessTokensCacheManager = activeAccessTokensCacheManager;
        this.accessTokenService = accessTokenService;
        this.type = type;
    }
    async getEntity(entity) {
        const cacheKey = `${this.getCachePrefix()}_${entity.sub}`;
        const cachedData = await this.entityCacheManager.get(cacheKey);
        if (cachedData) {
            if (this.isEmptyAccessToken(cachedData)) {
                throw new exceptions_1.FailedToAuthenticateException();
            }
            else {
                return cachedData;
            }
        }
        try {
            const data = await this.accessTokenService.getEntity(entity);
            await this.entityCacheManager.set(cacheKey, data, { expiresInSeconds: 10 });
            return data;
        }
        catch (e) {
            if (e instanceof exceptions_1.FailedToAuthenticateException) {
                await this.entityCacheManager.set(cacheKey, { empty: true }, { expiresInSeconds: 10 });
            }
            throw e;
        }
    }
    async getActiveAccessTokenIds() {
        const cacheKey = `${this.getCachePrefix()}_ids`;
        const cachedData = await this.activeAccessTokensCacheManager.get(cacheKey);
        if (cachedData) {
            return cachedData;
        }
        try {
            const data = await this.accessTokenService.getActiveAccessTokenIds();
            this.activeAccessTokensCacheManager.set(cacheKey, data, { expiresInSeconds: 10 });
            return data;
        }
        catch (e) {
            if (e instanceof exceptions_1.FailedToAuthenticateException) {
                await this.activeAccessTokensCacheManager.set(cacheKey, [], { expiresInSeconds: 10 });
            }
            throw e;
        }
    }
    shouldHandle(type) {
        return this.type === type;
    }
    isEmptyAccessToken(accessToken) {
        return 'empty' in accessToken && accessToken.empty;
    }
}
exports.CacheAccessTokenService = CacheAccessTokenService;
//# sourceMappingURL=cache-access-token.service.js.map