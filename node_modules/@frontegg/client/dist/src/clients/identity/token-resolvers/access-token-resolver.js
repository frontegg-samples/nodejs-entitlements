"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessTokenResolver = void 0;
const logger_1 = require("../../../components/logger");
const types_1 = require("../types");
const exceptions_1 = require("../exceptions");
const token_resolver_1 = require("./token-resolver");
const cache_1 = require("../../../cache");
const access_token_services_1 = require("./access-token-services");
const authenticator_1 = require("../../../authenticator");
const http_1 = require("../../http");
const frontegg_context_1 = require("../../../components/frontegg-context");
class AccessTokenResolver extends token_resolver_1.TokenResolver {
    constructor() {
        super([types_1.tokenTypes.TenantAccessToken, types_1.tokenTypes.UserAccessToken], types_1.AuthHeaderType.AccessToken);
        this.authenticator = new authenticator_1.FronteggAuthenticator();
        this.httpClient = new http_1.HttpClient(this.authenticator);
        this.accessTokenServices = [];
    }
    async validateToken(token, publicKey, options) {
        var _a, _b;
        await this.init();
        const entity = await super.verifyToken(token, publicKey);
        let entityWithRoles = null;
        if (((_a = options === null || options === void 0 ? void 0 : options.permissions) === null || _a === void 0 ? void 0 : _a.length) || ((_b = options === null || options === void 0 ? void 0 : options.roles) === null || _b === void 0 ? void 0 : _b.length)) {
            entityWithRoles = await this.getEntity(entity);
            await this.validateRolesAndPermissions(entityWithRoles, options);
        }
        else {
            const activeIds = await this.getActiveAccessTokenIds(entity);
            if (!activeIds.some((id) => id === entity.sub)) {
                throw new exceptions_1.FailedToAuthenticateException();
            }
        }
        return {
            ...(entityWithRoles || ((options === null || options === void 0 ? void 0 : options.withRolesAndPermissions) ? await this.getEntity(entity) : {})),
            ...entity
        };
    }
    async init() {
        const { FRONTEGG_CLIENT_ID, FRONTEGG_API_KEY } = frontegg_context_1.FronteggContext.getContext();
        await this.authenticator.init(FRONTEGG_CLIENT_ID || process.env.FRONTEGG_CLIENT_ID || '', FRONTEGG_API_KEY || process.env.FRONTEGG_API_KEY || '');
        this.initAccessTokenServices();
    }
    getEntity(entity) {
        const service = this.getAccessTokenService(entity.type);
        return service.getEntity(entity);
    }
    async getActiveAccessTokenIds(entity) {
        const service = this.getAccessTokenService(entity.type);
        return service.getActiveAccessTokenIds();
    }
    getAccessTokenService(type) {
        const service = this.accessTokenServices.find((accessTokenService) => accessTokenService.shouldHandle(type));
        if (!service) {
            logger_1.default.info('Failed to find access token service');
            throw new exceptions_1.FailedToAuthenticateException();
        }
        return service;
    }
    initAccessTokenServices() {
        var _a, _b;
        if (this.accessTokenServices.length) {
            return;
        }
        const accessTokensOptions = frontegg_context_1.FronteggContext.getOptions().accessTokensOptions;
        if (((_a = accessTokensOptions === null || accessTokensOptions === void 0 ? void 0 : accessTokensOptions.cache) === null || _a === void 0 ? void 0 : _a.type) === 'ioredis') {
            this.accessTokenServices = [
                new access_token_services_1.CacheTenantAccessTokenService(new cache_1.IORedisCacheManager(accessTokensOptions.cache.options), new cache_1.IORedisCacheManager(accessTokensOptions.cache.options), new access_token_services_1.TenantAccessTokenService(this.httpClient)),
                new access_token_services_1.CacheUserAccessTokenService(new cache_1.IORedisCacheManager(accessTokensOptions.cache.options), new cache_1.IORedisCacheManager(accessTokensOptions.cache.options), new access_token_services_1.UserAccessTokenService(this.httpClient)),
            ];
        }
        else if (((_b = accessTokensOptions === null || accessTokensOptions === void 0 ? void 0 : accessTokensOptions.cache) === null || _b === void 0 ? void 0 : _b.type) === 'redis') {
            this.accessTokenServices = [
                new access_token_services_1.CacheTenantAccessTokenService(new cache_1.RedisCacheManager(accessTokensOptions.cache.options), new cache_1.RedisCacheManager(accessTokensOptions.cache.options), new access_token_services_1.TenantAccessTokenService(this.httpClient)),
                new access_token_services_1.CacheUserAccessTokenService(new cache_1.RedisCacheManager(accessTokensOptions.cache.options), new cache_1.RedisCacheManager(accessTokensOptions.cache.options), new access_token_services_1.UserAccessTokenService(this.httpClient)),
            ];
        }
        else {
            this.accessTokenServices = [
                new access_token_services_1.CacheTenantAccessTokenService(new cache_1.LocalCacheManager(), new cache_1.LocalCacheManager(), new access_token_services_1.TenantAccessTokenService(this.httpClient)),
                new access_token_services_1.CacheUserAccessTokenService(new cache_1.LocalCacheManager(), new cache_1.LocalCacheManager(), new access_token_services_1.UserAccessTokenService(this.httpClient)),
            ];
        }
    }
}
exports.AccessTokenResolver = AccessTokenResolver;
//# sourceMappingURL=access-token-resolver.js.map