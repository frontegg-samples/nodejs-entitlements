"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenResolver = void 0;
const jsonwebtoken_1 = require("jsonwebtoken");
const logger_1 = require("../../../components/logger");
const exceptions_1 = require("../exceptions");
class TokenResolver {
    constructor(allowedTokenTypes, type) {
        this.allowedTokenTypes = allowedTokenTypes;
        this.type = type;
    }
    async verifyToken(token, publicKey) {
        const entity = await this.verifyAsync(token, publicKey);
        this.validateTokenType(entity.type);
        return entity;
    }
    validateTokenType(tokenType) {
        if (!this.allowedTokenTypes.some((type) => type === tokenType)) {
            logger_1.default.info('Invalid token type');
            throw new exceptions_1.InvalidTokenTypeException();
        }
    }
    async validateRolesAndPermissions({ roles: entityRoles, permissions: entityPermissions }, options) {
        if (options) {
            const { roles, permissions } = options;
            if (roles && roles.length > 0) {
                let haveAtLeastOneRole = false;
                for (const requestedRole of roles) {
                    if (entityRoles && entityRoles.includes(requestedRole)) {
                        haveAtLeastOneRole = true;
                        break;
                    }
                }
                if (!haveAtLeastOneRole) {
                    logger_1.default.info('Insufficient role');
                    throw new exceptions_1.InsufficientRoleException();
                }
            }
            if (permissions && permissions.length > 0) {
                let haveAtLeastOnePermission = false;
                for (const requestedPermission of permissions) {
                    if (entityPermissions && entityPermissions.includes(requestedPermission)) {
                        haveAtLeastOnePermission = true;
                        break;
                    }
                }
                if (!haveAtLeastOnePermission) {
                    logger_1.default.info('Insufficient permission');
                    throw new exceptions_1.InsufficientPermissionException();
                }
            }
        }
    }
    shouldHandle(type) {
        return this.type === type;
    }
    verifyAsync(token, publicKey) {
        return new Promise((resolve, reject) => {
            (0, jsonwebtoken_1.verify)(token, publicKey, { algorithms: ['RS256'] }, (err, decoded) => {
                const data = decoded;
                if (err) {
                    logger_1.default.error('Failed to verify jwt - ', err);
                    reject(new exceptions_1.FailedToAuthenticateException());
                    return;
                }
                resolve(data);
                return;
            });
        });
    }
}
exports.TokenResolver = TokenResolver;
//# sourceMappingURL=token-resolver.js.map