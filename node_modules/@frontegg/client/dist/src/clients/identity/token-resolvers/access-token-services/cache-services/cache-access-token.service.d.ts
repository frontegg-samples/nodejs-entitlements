import { IAccessToken, IEmptyAccessToken, IEntityWithRoles, tokenTypes } from '../../../types';
import { IAccessTokenService } from '../access-token.service.interface';
import { ICacheManager } from '../../../../../cache/cache.manager.interface';
export declare abstract class CacheAccessTokenService<T extends IAccessToken> implements IAccessTokenService<T> {
    readonly entityCacheManager: ICacheManager<IEntityWithRoles | IEmptyAccessToken>;
    readonly activeAccessTokensCacheManager: ICacheManager<string[]>;
    readonly accessTokenService: IAccessTokenService<T>;
    readonly type: tokenTypes.UserAccessToken | tokenTypes.TenantAccessToken;
    constructor(entityCacheManager: ICacheManager<IEntityWithRoles | IEmptyAccessToken>, activeAccessTokensCacheManager: ICacheManager<string[]>, accessTokenService: IAccessTokenService<T>, type: tokenTypes.UserAccessToken | tokenTypes.TenantAccessToken);
    getEntity(entity: T): Promise<IEntityWithRoles>;
    getActiveAccessTokenIds(): Promise<string[]>;
    shouldHandle(type: tokenTypes.UserAccessToken | tokenTypes.TenantAccessToken): boolean;
    private isEmptyAccessToken;
    protected abstract getCachePrefix(): string;
}
